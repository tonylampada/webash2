Technical Specification: Web-Based Terminal Emulator

Architecture Overview

The system will be a single-process web application providing a browser-based terminal interface that connects to a shell running on the server. The architecture consists of two main parts:
	•	Backend Server (Single Process): Runs on a Linux system, responsible for spawning and managing shell processes (one per terminal tab) and handling communication with the browser via WebSockets. It also serves the static frontend files (HTML, CSS, JS) on the same port, fulfilling the “monoprocesso” requirement.
	•	Frontend Client (Web Page): A responsive web interface (mobile-first design) that emulates a terminal. It uses a JavaScript terminal emulator library in the browser to display output and capture user input. Multiple terminal tabs are supported, each maintaining an independent WebSocket connection to a corresponding backend shell process.

Communication Flow: When the user types a command or keystroke in the web terminal, the frontend sends that input over a WebSocket to the backend. The backend writes this to the shell’s pseudoterminal (PTY). The shell’s output (including all ANSI control codes for colors, cursor movement, etc.) is read from the PTY and forwarded back via WebSocket to the frontend, which renders it in the terminal UI ￼ ￼. This bi-directional communication is real-time, enabling an experience similar to a native terminal.

Persistent Sessions: Each terminal tab corresponds to a long-running shell process on the server. These processes remain running even if the browser or tab is closed or the connection drops, allowing the user to reconnect later and resume the session (as per the PRD’s persistence requirement). The backend will keep shell processes alive until it receives an explicit kill instruction (e.g. the user closes that tab from the UI) or the process naturally terminates (user types exit or similar).

Technology Stack Decision

After evaluating the options (Node.js vs Python FastAPI), Node.js is chosen for the backend implementation. The decision is based on several factors:
	•	Mature PTY Support: Node has the well-established node-pty library, which makes it straightforward to spawn and interface with a pseudoterminal for running a shell ￼ ￼. This library is widely used in similar projects (e.g. WeTTy) and handles low-level PTY details across platforms. Although Python’s pty module could be used (as shown by projects like pyxtermjs which use Flask + SocketIO ￼), Node’s ecosystem offers a slightly smoother integration for this use case.
	•	Real-time Communication: Node’s event-driven architecture and WebSocket support (via libraries like ws or socket.io) are well-suited for the low-latency, full-duplex communication needed. Both Node and Python can handle WebSockets, but Node’s single-threaded event loop simplifies concurrent I/O handling. (Python’s FastAPI would require using async features or an async server for websockets, which is feasible but adds complexity.)
	•	Single-Process Simplicity: Node can easily serve static files and WebSocket endpoints on one port using a lightweight framework like Express (or even the built-in HTTP module), meeting the requirement of a single-port deployment. This avoids running separate front/back servers. FastAPI could also serve static files and websockets on one port, but would introduce an additional dependency on ASGI servers and possibly eventlet/gevent for SocketIO, whereas Node has fewer moving parts for this scenario.
	•	Community Examples: There are more example projects and community support for Node in this exact domain (e.g. WeTTy which uses xterm.js and Node, and is known to work well ￼). This reduces risk. Python solutions exist but are less common, so choosing Node leverages the “tried-and-true” path.

Given these points, the backend will be implemented in Node.js (JavaScript/TypeScript). The decision is in line with the user’s preference for either Node or FastAPI (we choose Node), and our target environment is a Linux server (as assumed).

Note: The choice of Node.js is mainly for ease of implementation. The developer could alternatively implement with Python + FastAPI if desired, using a similar architecture (as proven by pyxtermjs ￼), but for this specification we proceed with Node for clarity.

Backend Design

Backend Framework and Modules
	•	HTTP Server: Use Express.js (or a minimal alternative) to handle HTTP requests on a single port. It will serve the static frontend files (HTML, CSS, JS) and also act as the endpoint for WebSocket upgrades. Static files will be bundled with the application or served from a known directory (no separate build or CDN requirement, except including external libraries via <script> tags as needed).
	•	WebSocket Communication: Use the ws library (a simple WebSocket implementation) to handle terminal data exchange. Each terminal tab will have a dedicated WebSocket connection (identified by a session ID or path). When a WebSocket client connects, the server will either create a new shell process (for new tabs) or reattach to an existing shell process (for reconnections) based on the URL or an initial message. WebSocket was chosen for its low latency and full-duplex capabilities, which are necessary to achieve near real-time terminal interactivity ￼. (Using HTTP polling/Ajax would introduce unacceptable latency and complexity for a terminal.)
	•	Protocol: The WebSocket will carry raw byte streams. No high-level encoding is necessary beyond perhaps JSON messages with simple structure if we include control signals. However, in this case we can send raw data: the client sends raw keystrokes and control characters, and the server sends back the raw output stream. This keeps implementation simple; the Xterm.js frontend will interpret the bytes (including escape sequences) correctly ￼.
	•	Shell Process Management: Use node-pty to spawn a shell (e.g. /bin/bash) with an associated pseudoterminal for each session. For example:

const pty = require('node-pty');
const shell = process.env.SHELL || '/bin/bash';
const ptyProcess = pty.spawn(shell, [], {
    name: 'xterm-256color',
    cols: 80, rows: 24,
    cwd: process.env.HOME,
    env: process.env  // carry over environment variables
});

This will launch a login shell. We set TERM=xterm-256color (node-pty does this by default when name is given as such) to ensure the shell and programs produce color output and use terminal control codes suitable for xterm ￼. The working directory can default to user’s home or a configurable path. We will rely on the OS for shell behavior (prompt, command execution, etc.), which means features like history, prompt text, and handling of arrow keys are naturally provided by the shell itself (e.g. Bash manages history and arrow-key navigation internally when connected to a PTY ￼).

	•	Session ID and Lifecycle: Each shell/PTY is associated with a session ID (e.g. a UUID or incremental integer). The backend will maintain an in-memory map of active session IDs to their PTY processes and WebSocket clients. Workflow:
	•	When the frontend requests a new terminal tab, it will call an HTTP endpoint (e.g. POST /terminals) or initiate a WebSocket connection to a special URL (e.g. ws://server/terminals/new). The server will create a new shell process via node-pty, store it in the session map, and return a session ID (if via HTTP) or communicate it over the WebSocket. The client will then use that ID for subsequent connections.
	•	The client establishes a WebSocket to a path including the session ID (e.g. ws://server/terminals/<sessionId>). The server looks up the corresponding PTY. If this is a reconnection (the PTY already exists and is running), the server will attach the new WebSocket listener to the existing PTY’s output stream. This design allows the user to reconnect to an existing terminal process after closing a browser or losing connection.
	•	If a WebSocket disconnects unexpectedly (e.g. network issue or browser closed), the server will not immediately kill the PTY. The process will continue running in the background (potentially producing output that will be unseen until reconnected). The session remains in the map marked as “detached”. We will implement a reasonable retention policy: e.g. keep detached sessions alive indefinitely (since use is personal and memory usage is low) or possibly terminate after a very long timeout if needed. Memory use is not a major concern for a few shell processes (as noted, terminals are lightweight) ￼.
	•	When the user explicitly closes a tab in the UI, the frontend will send a message (over the WebSocket or via a dedicated control message) to instruct the backend to terminate that session. On receiving this, the server will kill the PTY process (send SIGHUP or simply ptyProcess.kill() which ends the shell) and remove it from the session map. This ensures that closing a tab frees resources as required. Also, if the shell process ends on its own (e.g. user types exit or the process terminates), the server should detect the PTY closure and notify the frontend (maybe by closing the WebSocket or sending a special “session ended” message) so that the UI can close that tab.
	•	PTY <-> WebSocket Data Handling:
	•	Attach an event listener to the PTY process for data output. Whenever the shell produces output, the callback will fire with a chunk of data (string or Buffer). The server will immediately forward that to the appropriate WebSocket. No filtering or processing of the output is needed – it should be relayed raw, as it contains necessary control codes (for moving cursor, colors, etc.) ￼. (We do not attempt to parse or interpret the shell output on the server; the frontend emulator handles that.)
	•	Attach a listener on the WebSocket for incoming messages. When the browser sends input (keystrokes), the server writes it to the PTY (e.g. ptyProcess.write(data)). This can include special characters like \r (Enter), \u0003 (Ctrl+C), etc., which will be processed by the shell. The PTY will handle echoing if the terminal is in canonical mode; typically, the shell will echo typed characters and handle line editing unless in raw mode ￼. We do not echo input on the server; we rely on the PTY/shell to echo to output if appropriate (this prevents double-echo issues).
	•	Terminal Resize: The frontend will detect if the terminal UI size changes (e.g. device rotated or keyboard opened, affecting available rows/cols). It should send a resize event with new columns and rows. The server will call ptyProcess.resize(cols, rows) to adjust the pseudo-terminal size ￼. This ensures that line wrapping and programs like vim or nano that query the terminal size behave correctly. On initial creation, we set a default size (e.g. 80x24 or the current container size); the frontend can immediately send an actual size after rendering to sync the PTY.
	•	Static File Serving: The backend will serve the static files (the HTML page, CSS, JS, and any asset) from the same process and port. For example, a GET to / returns the HTML, which includes references to the JS/CSS. We will not use any build system or Node bundler – the files will be pre-written and served as-is. Libraries like Xterm.js or potential UI frameworks can be included via CDN links or by hosting their files. This satisfies the requirement of “no complex build and a single command to start the backend”.
	•	Logging and Debug: For development, the server can log session start/stop and possibly some user actions, but since it’s a personal tool, minimal logging is needed. We should handle errors gracefully (e.g. if a PTY fails to spawn or if a WebSocket communication error occurs).

Security and Access Control

This application is intended for personal use, so no authentication or multi-user separation is implemented (out of scope). Important: This means anyone who can connect to the server port can potentially access a shell with the same privileges as the server user. In a personal setup, it’s assumed the user will run this on a secure network or localhost. If exposure to the internet is needed, the user should secure it (e.g. via SSH tunneling or adding simple HTTP auth in a reverse proxy). By default, we will bind the server to localhost or a user-specified host, and document that it’s not secure for multi-user or public deployment.

We also will not implement any sandboxing beyond what the OS inherently provides. The shell has full access to the user’s system permissions. This is acceptable given the target user is the developer themselves.

Because we are not using HTTPS or WSS by default (again assuming local usage), if accessed over a network, unencrypted WS traffic could be sniffed. The user can choose to run behind an HTTPS proxy if needed. For simplicity, the spec assumes a local or otherwise secure context.

Backend on Linux

The server will run on a Linux environment (requirement). We will spawn a Linux shell (by default /bin/bash -i). The code will likely work on macOS as well (with minor tweaks), but Windows would require different handling (node-pty supports Windows by using ConPTY or winpty, but we won’t focus on that). We ensure the implementation uses Unix PTY calls suitable for Linux.

Memory and CPU considerations: Running a few shell processes (and one Node process) is not resource-intensive. Terminal sessions typically consume minimal CPU when idle and modest memory (a bash process and its PTY). The Node process will mainly be I/O bound and can handle the expected throughput easily. Given that it’s single-user, we do not anticipate performance bottlenecks. Real-time updates over WebSocket mean latency should be well below the 100ms target in a local network scenario, which meets the performance requirement.

Frontend Design

Overview of UI

The web frontend provides a terminal emulator interface with support for multiple tabs and mobile-friendly interactions. It will be a single-page application (SPA) loaded from an index.html that contains the terminal container and necessary script includes. The UI elements include:
	•	Terminal Display Area: This is where the terminal text (output and input echo) is rendered for each tab. We will use Xterm.js – a popular open-source JavaScript terminal emulator – to render the terminal output within this area. Xterm.js is a full-fledged terminal emulation library that supports ANSI escape codes, colors, and cursor control sequences ￼. It is used in projects like VS Code and Wetty, indicating maturity and reliability ￼. Using Xterm.js means we don’t have to implement low-level terminal parsing; we feed it the data stream from the server and it displays the terminal exactly as a native terminal would.
	•	Tab Bar: A UI element (likely at the top of the page on desktop, or accessible via a menu on mobile if space is constrained) that shows all open terminal sessions. Each tab will have a title like “Tab 1”, “Tab 2”, etc., and a close button (an “X”). The active tab is highlighted. Clicking a tab switches the view to that terminal session; clicking the close button on a tab will prompt closure (with potential confirmation if needed) and send the kill signal to the backend for that session. There will also be an “Add Tab” button (e.g. a “+” icon) to open a new terminal. On mobile, the tab bar might be scrollable if many tabs are open, or possibly a dropdown if screen space is limited.
	•	Mobile Special Keyboard Bar: A custom on-screen function bar that provides special keys and controls not easily accessible on mobile keyboards. This bar will be shown at the bottom of the screen (just above the device’s native keyboard, if possible) or as an overlay that can be toggled. It will include buttons for:
	•	Ctrl key – for sending Control key combinations.
	•	Arrow keys: Up, Down, Left, Right – to navigate shell history or move cursor in editors.
	•	Tab – for auto-completion in the shell.
	•	Esc – escape key (useful for vim or interrupting prompts).
	•	Copy – (optional) to initiate copying text from the terminal (details below).
	•	Paste – (optional) to paste from clipboard into the terminal.
These buttons address the PRD requirement of supporting keys like Ctrl and arrows on mobile. Many mobile soft keyboards lack arrow keys or a Ctrl key, so without this, using the terminal would be frustrating. The Ctrl key behavior will be implemented such that pressing the “Ctrl” button will modify the next key press sent to the terminal as a Ctrl combination. For example, tapping “Ctrl”, then tapping “c” on the regular keyboard (or a “C” button if provided) would send a Ctrl+C to the terminal (SIGINT). Implementation-wise, when “Ctrl” is active (we can indicate this by highlighting the button when pressed), the frontend will intercept the next key event and prepend a control modifier before sending. After one use, it can auto-release or toggle off. We will need to manage state for this (a boolean indicating “Ctrl” is currently pressed in the virtual sense).
The arrow keys and others will simply send their corresponding key codes via the WebSocket. For instance, pressing the “Up” arrow button will send the ANSI escape sequence for Up (which is \x1b[A). Xterm.js can generate these sequences on key events normally, but since we are handling a virtual button, we may directly send the sequence or programmatically trigger a key event on the Xterm terminal object.
The Paste button will utilize the modern Clipboard API if available. On tapping “Paste”, we can call navigator.clipboard.readText() (which typically requires a user gesture, so the button click qualifies) and then insert the retrieved text into the terminal input stream (effectively simulating the user typing that text). This allows pasting text on mobile, where Ctrl+V is not an option. Similarly, a Copy button can call navigator.clipboard.writeText(selectedText) to copy text that has been selected (see next section about text selection). These features enhance usability on mobile.
	•	Responsive Layout: The UI will be styled with CSS to be mobile-first responsive. On a small screen (portrait mobile phone), the terminal area will occupy most of the screen. The special keyboard bar appears above the system keyboard. The tab bar may be collapsed into a top dropdown or horizontal scroll list. On a larger screen (desktop or landscape tablet), the tab bar can be always visible at top, and the special keys bar might either be hidden (since a physical keyboard likely exists with these keys) or shown if toggled. We will use media queries or dynamic detection to adjust these elements. Ensuring the terminal text is readable and the input area isn’t obscured by the on-screen keyboard is crucial. Techniques include using viewport meta tags (e.g. viewport-fit=cover for iOS) and possibly adjusting bottom padding when the keyboard is open (some mobile browsers provide events or we can detect focus on the input field Xterm uses and adjust scrolling).

Integrating Xterm.js for Terminal Emulation

Library inclusion: We will use the latest stable version of Xterm.js. It can be included via a CDN (for example, unpkg: <script src="https://unpkg.com/xterm@latest/lib/xterm.js"></script> and its CSS <link rel="stylesheet" href="https://unpkg.com/xterm@latest/css/xterm.css">). This avoids needing a build step. (Alternatively, we can download the minified JS/CSS and serve them with our static files.)

Terminal initialization: For each tab, we create an Xterm Terminal object. Example in plain JS:

const term = new Terminal({ 
    cols: 80, rows: 24,
    fontFamily: 'monospace',
    theme: { background: '#000000', foreground: '#FFFFFF' } 
});
const fitAddon = new FitAddon.FitAddon();
term.loadAddon(fitAddon);
term.open(document.getElementById('terminal-container-1'));
fitAddon.fit();  // fit terminal to container size

We use the FitAddon that Xterm.js provides to auto-resize the terminal to fill the container element. This will be called on window resize or orientation change to dynamically adjust the number of rows/cols to the container. After fitting, we should inform the backend of the new size (sending a resize message as mentioned).

WebSocket hookup: Once the WebSocket for a tab’s session is open, we connect it to Xterm:
	•	On WebSocket message (data from backend): call term.write(data) to push output into the terminal ￼.
	•	On Xterm key input: Xterm.js provides an API term.onData(callback) which fires for each input keystroke (and special key) when the user types ￼. In that callback, we send the data over WebSocket to the server. This covers normal keyboard input. For our virtual special keys, we will also send the corresponding sequences through the same WebSocket.

Text selection and copy: One critical requirement is that the user must be able to select and copy text from the terminal output, especially on mobile. By default, Xterm.js on desktop allows text selection with the mouse (you can click and drag to select text, and then copy with Ctrl+C or context menu). However, on mobile/touch devices, text selection is not straightforward – in fact, it’s not natively supported by Xterm on iOS as of recent versions (touch events do not create a selection) ￼. We need to implement a solution to enable selection on touch devices.

We have a couple of strategies to achieve this:
	•	Simulate Mouse Events on Touch: We can capture touch events on the terminal’s element and translate them into synthetic mouse events to trick Xterm into thinking a mouse is selecting text. For example, on a touchstart, we could record the touch point, and on touchmove, dispatch a mousedown+mousemove with coordinates, then on touchend, a mouseup. A community user has reported success with this approach ￼ – by mapping touch events to mouse events, they enabled text selection on iPad. We will implement a variant of this: basically, detect a long-press or touch-and-drag gesture on the terminal and use Xterm’s term.select API or event injection to select the text range. Xterm.js does have methods like term.getSelection() (to get selected text) and term.selectAll(), but no direct method to select at coordinates. We may calculate row/column from touch Y/X by using the terminal’s character size (available via API or known from CSS). This is a bit involved but feasible.
	•	“Copy Mode” Toggle: Another approach to ensure copy capability on mobile is to introduce a special mode or button. For instance, a Copy button in the special key bar that, when tapped, could do one of two things:
	1.	Copy Entire Screen: Simply call term.getSelection() after programmatically selecting the visible range or entire scrollback, then use clipboard.writeText to copy it. This would allow at least copying all text, but not selective portions.
	2.	Toggle Selection Mode: When activated, temporarily overlay an invisible text layer or switch Xterm to a selection-friendly state. One idea: Xterm.js has a DOM renderer option (which renders text in actual DOM elements instead of canvas). The user in an Xterm issue tried the DOM renderer but still couldn’t select with touch ￼. Alternatively, we can retrieve all text content from Xterm’s buffer (it provides an API to access buffer lines), and display it in a <pre> element over the terminal, allowing the user to use the native text selection of the browser (since it’s standard text at that point). This is a workaround: essentially a read-only text view of the buffer for selection purposes. Once the user highlights what they want and copies (via the browser’s built-in copy menu), they can toggle back to interactive mode. This approach ensures we respect exactly what text was on screen (including colors if we preserve ANSI styling in the <pre> by applying spans with style).

Given the implementation complexity, the simplest plan is to attempt the first strategy (simulate mouse events on touch) to allow direct selection on the terminal. We will document any limitations (for example, on iOS Safari, users might need an external keyboard to easily copy, due to Safari’s restrictions on JavaScript clipboard without user gesture, etc.). The goal is that a user can long-press and drag to select text on mobile. It may not be as smooth as native, but it should work. We’ll also include a Copy button that on tap, copies whatever is currently selected in the terminal (Xterm’s getSelection() gives the text currently highlighted ￼ ￼). This provides an explicit way to copy after selecting (since Ctrl+C or menu may not be available on mobile).

ANSI Colors and Text Style: Xterm.js will render text with colors as long as the escape codes are present and the terminal’s theme is configured. We will ensure the default theme has a dark background (e.g. black or a dark gray) and a palette that makes colored text visible. For example, if using the default Xterm theme, directory listings or Git diffs will show colored text properly on black. We explicitly set theme.background = '#000000' (black) and maybe theme.foreground = '#d0d0d0' (light gray) or leave foreground as default white. Xterm.js has a 16-color palette that matches typical terminal colors; we can leave that default, which will inherently “respect the colored fonts of the terminal output” as required (i.e. if the shell or programs output colored text, it will display in those colors) ￼. We will also support dark mode exclusively – since this is a terminal, a dark theme is expected. (If needed in future, a light theme toggle could be added, but not in scope now.)

To maintain a cohesive look, we may apply a CSS framework or minimal custom CSS for other UI elements (tab bar, buttons) with a dark theme (e.g. dark background, light text, using perhaps the Nord or Catppuccin color palette mentioned as inspiration). However, the core terminal area will be classic black background. The fonts will be a monospace font stack that is well-supported on mobile and desktop (like font-family: Menlo, Consolas, monospace;). Font size might default to ~14px for readability on mobile, but possibly adjustable via pinch-zoom or settings (not required but could be nice to allow zoom).

Tab Management Implementation

Managing multiple terminals in the frontend involves keeping multiple Terminal objects and WebSocket connections alive and switching between them:
	•	We will maintain a list/array of active sessions in the frontend state. Each entry has the session ID, a reference to the Xterm Terminal object, and the WebSocket connection.
	•	When the user clicks “+” to open a new tab:
	•	We send a request to the backend to create a new session (via REST POST or an open-then-initialize WebSocket). The backend returns a new session ID.
	•	We create a new Terminal object (as described above), open it in a new tab container (a new <div> in the DOM for that terminal’s content).
	•	We initiate a WebSocket connection to the server for that session ID. Upon connection, we link the onData and onMessage events as described so that input/output flows.
	•	We add a new tab element to the tab bar UI with the label (e.g. “Tab 3” if it’s the third one) and attach event handlers for switching and closing.
	•	The new tab becomes the active one (we hide the previous terminal’s div and show this one, and update tab styling).
	•	Switching tabs:
	•	We hide the currently active terminal’s <div> and show the selected one’s <div>.
	•	We call term.focus() on the Xterm of the newly active tab, so that it can capture keyboard input immediately.
	•	(On mobile, focusing might not bring up keyboard automatically unless perhaps an input field is focused; Xterm usually uses a hidden textarea to capture input. We might need to ensure that hidden textarea is focused. Xterm’s term.focus() should handle this in most cases.)
	•	Closing a tab:
	•	When the user clicks the “X” on a tab, we retrieve that session ID, and remove that Terminal instance. We will:
	•	Send a message to backend to terminate that session. For example, we could send a JSON message over the WebSocket like {"action": "EXIT"} or simply call an HTTP DELETE endpoint for that session. Alternatively, closing the WebSocket could implicitly signal a termination if we program it that way, but it’s safer to explicitly tell the server to kill the process.
	•	Close the WebSocket connection for that tab.
	•	Dispose the Xterm object (call term.dispose() to free resources).
	•	Remove the tab’s DOM elements (the tab button and terminal container).
	•	If that tab was active, switch to another tab (e.g. the one to the left, or if none left, create a new session or show a message “No terminals open”).
	•	The backend upon receiving the kill instruction will kill the PTY process and remove it from memory. If the user closes the entire browser or disconnects without using the “X”, the session remains (as per persistence), and we covered that logic on the backend. But if they never reconnect, those might linger indefinitely; since this is personal use, a few lingering shells are not critical. The user can manually clear them by connecting and closing or by restarting the server.
	•	Reconnection logic: If the user reloads the page or opens the app in a new browser instance, we want to restore any still-running sessions. To facilitate this, we can implement the following:
	•	The backend could provide an endpoint to list active session IDs (since we have them in memory). For example, GET /terminals returns JSON of all session IDs still alive.
	•	When the frontend loads initially, it can fetch this endpoint. If it returns any IDs, it means those sessions were left running. The frontend can then present a UI to “Reattach to previous sessions” or automatically re-open them as tabs. Because we might not know how many there were or their order, a simple approach is to re-open all of them in order of creation. We might give them generic names or if we stored custom titles (not in current scope).
	•	Each reattached tab would open a WebSocket to that session and spawn an Xterm as usual. One caveat: the Xterm will be fresh and will not have the scrollback of what was printed while it was disconnected. We cannot fully recover that unless we had been logging output on the server side. By default, we are not storing the full output history (to keep the server simple and memory low). So upon reattachment, the user will see the terminal from that point forward. They might have missing context from while it was disconnected. However, many commands’ output can be re-displayed by the user if needed (or one could scroll in a screen/tmux if they use those). Documenting this limitation is wise. If we wanted to be thorough, we could buffer the last N lines of output in memory for each session and send that upon reconnection to prime the Xterm. This is an enhancement we can suggest but not mandatory.
	•	Alternatively, the user can run commands like dmesg or their own logs to see past output if needed. Given personal use, this is likely acceptable.
Implementation detail: to identify sessions for reattachment, using localStorage on the browser could also work (store open session IDs on unload). But relying on the backend truth is safer in case the user switches device. We assume single user but they might want to connect from phone and later from desktop to the same running sessions. By having a GET /terminals that lists sessions (IDs and maybe a snippet of last output or status), any client can reconnect. We won’t implement multi-user isolation, so any client hitting that endpoint can see and attach to all sessions. Since it’s the same person, that’s fine.

Mobile-Specific Usability Considerations

Mobile browsers present unique challenges for terminal UIs:
	•	Focus and Keyboard: Ensuring the on-screen keyboard appears when needed. On mobile, tapping the terminal should focus the hidden input to bring up the keyboard. We might need to explicitly call something to trigger it; Xterm.js often focuses a hidden textarea on container click. We will double-check this behavior on mobile Safari/Chrome. We might implement a tap handler on the terminal container that ensures focus.
	•	Screen Space: The terminal should scroll as new output comes if it doesn’t fit on screen. Xterm by default will handle scrollback internally (it keeps a buffer and allows scrolling within the terminal). We should ensure that the on-screen keyboard’s appearance doesn’t completely hide the terminal. Setting the viewport height CSS for the terminal container dynamically might be needed (there are known issues with 100vh on mobile when the keyboard opens). We can handle this by adjusting height to calc(100vh - <keyboard_height>) if we can detect it, or using CSS trick @supports (-webkit-overflow-scrolling: touch) etc. This will be tested during implementation.
	•	Text Selection UI: As discussed, selecting text on mobile will likely involve a custom solution. We will test on both Android and iOS browsers. Android might allow some selection if long-pressing on text (need to see if Xterm’s canvas/DOM allows it). iOS Safari tends to not allow selection on canvas easily, thus our simulated event approach is key. We also note that copying to clipboard on mobile usually involves the native context menu (“Copy” option on selection). We will verify that once text is selected (highlighted) in Xterm, iOS shows the “Copy” popup. If not, our “Copy” button approach will call the Clipboard API as a fallback.
	•	Performance on Mobile: Xterm.js can be heavy if a lot of text is output rapidly (like running cat on a large file). We assume usage will be moderate and on modern devices, but it’s something to consider. If performance issues arise, an alternative might have been needed (like the lighter-weight hterm or term.js). However, given this is 2025 and devices are powerful, Xterm at the scale of personal use should be fine. We ensure to not do inefficient things in the UI (like we will avoid unnecessary reflows or heavy libraries; we chose mostly vanilla JS).

Alternative Libraries Consideration (and Rejection)

We researched alternatives to Xterm.js in case it didn’t meet mobile usability requirements:
	•	jQuery Terminal (jcubic’s terminal emulator): It supports ANSI color and has an API for handling commands. However, it is primarily line-oriented (you provide a command interpreter function). Using it to attach to a real shell would require sending the full input line to the server and printing output line by line. It would not naturally support interactive programs (like editors or prompts) because it’s not a true PTY stream handling; it’s meant for building command interfaces. Moreover, its mobile support is experimental and has known open issues ￼. This made it a less suitable choice for a faithful, interactive shell experience.
	•	WebTUI: This is a CSS/TS library for “terminal-inspired” UI components and themes. It provides the look and feel (including themes like Nord, Catppuccin) for web apps that want a retro terminal aesthetic. However, it’s not actually an emulator for a real shell. It doesn’t automatically wire up to a backend process. We would have had to pair it with some lower-level communication mechanism. Essentially, WebTUI is more for building apps with a TUI style, not for exposing a live OS shell. Thus, while we might draw inspiration from its design (especially for dark theme colors), we didn’t choose it as the core terminal engine.
	•	Shell.js (and similar): Shell.js is a library that creates fake terminal windows in a page, where you can define commands that produce output ￼. It’s useful for making a simulated bash interface for a website (for example, a portfolio site that lets visitors type preset commands). It is not designed to connect to a real shell process. It wouldn’t automatically handle continuous output or interactive programs. Therefore, it’s not applicable for our needs (which require connecting to a real backend shell).
	•	Term.js (legacy): Term.js is the precursor to Xterm.js. Interestingly, some users noted that term.js allowed copy/paste on iPad fully, whereas modern Xterm.js did not ￼. We considered if using term.js (which is simpler) could solve the copy issue. However, term.js is an older, unmaintained project; Xterm.js was created as its successor with many fixes and enhancements (like better performance and Unicode support). The lack of maintenance and other missing features made it risky to use term.js just for the sake of copy functionality. Instead, we choose to stick with Xterm.js and implement the needed fixes for mobile.

In summary, Xterm.js remains the best choice due to its completeness (support for “curses” based applications, UTF-8, wide character support, scrollback, etc.) and active maintenance. We mitigate its mobile shortcomings with custom code. This approach gives us full terminal fidelity on desktop and a workable solution on mobile.

Non-Functional Requirements and Considerations

Usability (Mobile-First): The interface is kept as minimal as possible to maximize the terminal view on small screens. We will use touch-friendly sizes for buttons (e.g. the special key buttons will be large enough to tap easily, around 40px height). The color scheme (dark mode) is chosen for comfort during long terminal sessions and to align with typical terminal color expectations. Text selection and copy on mobile, while challenging, is addressed so that the user can reliably copy output when needed – an essential feature, for example, to copy a command result or an error message from the phone.

Performance: The app should start with a single command (e.g. node server.js), and within a couple of seconds the server is up. The initial load of the webpage might include Xterm.js (~200KB JS) which is reasonably fast on 4G or better networks. We aim for the terminal echo latency to be negligible on a local network (far under 100ms). Using WebSockets ensures we meet this target easily for each keystroke. The backend being single-process means context switching overhead is minimal. In testing, we’ll ensure that even rapid outputs (like yes command or dmesg flood) don’t crash the frontend – Xterm.js can handle a large scrollback but to be safe, we can configure a scrollback limit (e.g. 1000 lines) to bound memory usage in the browser.

Memory use is expected to be low: each session is essentially a Bash process (~5-10MB RSS typically) and Xterm’s data structures for scrollback. The Node server might use tens of MBs at most. The user explicitly noted that RAM is not a concern for a few terminal sessions ￼, and our design aligns with that.

Dark Mode and Theming: The default (and only, at this stage) theme is dark mode. All UI elements (background of page, tab bar, etc.) will use dark colors (e.g. dark charcoal grey #222 or pure black #000) with light text. We will ensure that the terminal area’s background is exactly the same or seamlessly blends with the rest of the page background if visible. Xterm’s default ANSI color palette will be in effect, which means standard command outputs that use colors (LS_COLORS, Git output, etc.) will appear with those colors on the dark background ￼. We must take care that our CSS doesn’t override the colors that Xterm applies. Typically, including the Xterm.css will handle styling of the terminal canvas or text properly. We might adjust the cursor color or selection highlight color if needed (Xterm allows setting a theme.selection color). For example, a semi-transparent selection background color could be set so that selected text is clearly highlighted (e.g. blue highlight) – useful in both desktop and mobile contexts.

Accessibility: Although not explicitly requested, we should ensure the solution is usable. For instance, color contrast on dark background should be sufficient (the default xterm colors are generally okay, though some like blue might be a bit low contrast on black; we can tweak the palette if needed for better visibility). The font size can be user-adjustable via pinch zoom as a simple approach (since it’s just a webpage), or we can allow a settings slider (out of scope for now, but possible future enhancement).

Error Handling: If the WebSocket connection fails (e.g. server down), the frontend will show an error message in the terminal area like “Disconnected” and possibly attempt to reconnect. For reconnection logic, using an exponential backoff can be done if connection is lost unexpectedly. However, since this is personal use, a manual refresh by the user might be acceptable. Still, implementing auto-reconnect for a short period can enhance experience (if Wi-Fi drops for a moment, the app should recover). If the backend restarts, all previous sessions will be lost (since not stored on disk). The UI should then not list old sessions (the GET /terminals would return none). This is acceptable; persistence is only in-memory for the life of the server process.

Testing: We will test the application on:
	•	Mobile Safari and Chrome (Android) for touch interactions (special keys, selection).
	•	Desktop Chrome/Firefox for normal usage (ensuring Ctrl+C, Ctrl+V etc. work as expected and multiple tabs function).
	•	Different screen sizes to verify responsive layout (using CSS flexbox or grid for the page can help adapt the terminal size when the keyboard appears/disappears).

Timeline (Implementation Plan):
	•	Day 1-2: Library Integration Research – Confirm usage of Xterm.js API, test a basic Node-pty + WebSocket + Xterm loop on desktop (a quick prototype) ￼. Also test Xterm on mobile in this basic setup to identify any immediate issues (especially with text selection).
	•	Day 3-5: Backend Implementation – Set up the Node server, integrate node-pty, manage multiple sessions, ensure new session creation and data piping works. Implement basic WebSocket handling and static file serving. Test that multiple concurrent PTYs can run (open two tabs in a desktop browser).
	•	Day 5-7: Frontend Implementation (Desktop-focus) – Build the tab UI, initialize Xterm for each tab, handle switching, and ensure basic keyboard input/output works. This includes implementing the creation of new tabs and closing tabs with the corresponding backend calls.
	•	Day 8-10: Mobile Optimization – Add the special keys toolbar and implement the touch-specific features: Ctrl modifier logic, arrow key buttons, and especially the text selection/copy mechanism for mobile. Iteratively test on an actual mobile device or emulator, refining the touch-to-mouse event mapping for selection until the user can reliably highlight text. Also, test the Copy/Paste buttons using the Clipboard API on mobile (may require serving over HTTPS or localhost with proper flags, since some clipboard functions require secure context).
	•	Day 11-12: Polish and UX – Improve the styling: dark theme colors for tabs and buttons, nice icons (maybe use SVGs or an icon font for things like the plus sign, X, arrows, etc., served locally). Ensure the layout is intuitive (e.g. maybe label the special keys or use recognizable icons like ⌨️ for keyboard toggling, etc.). Ensure that when the device is rotated or resized, the terminal resizes and the PTY gets the update.
	•	Day 13-14: Testing and Fixing – Do a full pass of testing all functionalities: open/close tabs, persistence (close browser and reopen), running long commands, checking that closing a tab truly kills the process (verify on server side). Fix any bugs (e.g. double input, or special keys sending wrong codes, etc.). Also test edge cases like extremely rapid output, or sending non-ASCII characters, etc.
	•	After this, the application should meet the success criteria outlined in the PRD.

Conclusion

By following this specification, a developer can implement a web-based terminal emulator that is personal-use optimized, especially for mobile. We have made key technical decisions (Node.js backend with WebSockets and Xterm.js frontend) and outlined how to implement crucial features like multi-tab support, persistent backend processes, and mobile text selection. Each component and interaction has been detailed so that the coding agent “doesn’t need to think” beyond translating this design into code. The end result will be a dark-themed, responsive web terminal that closely mimics a native terminal experience, fulfilling all the functional requirements described in the PRD.

References Used in Design:
	•	The integration of a PTY with Xterm.js over websockets is informed by the pyxtermjs project ￼ ￼ and common patterns in similar tools.
	•	Xterm.js’s limitation on mobile selection (not natively supporting iOS text selection) has been documented in its issue tracker ￼. We address this with custom event handling as suggested by community solutions ￼.
	•	Alternatives like jQuery Terminal were noted to have only experimental mobile support ￼, reinforcing our choice to stick with Xterm and customize it for mobile.
	•	The requirement to maintain ANSI colors and a dark theme leverages Xterm’s capabilities to render terminal escape codes properly ￼.
	•	We also considered known tools (Wetty, etc.) which use similar stacks, confirming the viability of our approach ￼.
